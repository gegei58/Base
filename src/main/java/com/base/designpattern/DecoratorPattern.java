package com.base.designpattern;

/**
 * @desc: Created by Fengyun on 4/26/2018.
 *
 * 装饰模式
 *
 * 在不直接修改现有类或创建子类的情况下 创建一个装饰类动态扩展该类功能
 *
 * 角色
 *      被装饰类实现的接口
 *      被装饰类
 *      装饰类
 *
 * 优点
 *      装饰者模式比继承更灵活 因为它以动态的方式来扩展对象的功能, 运行时可以选择不同的装饰器从而实现不同的行为
 *
 *      通过使用不同的装饰类以及这些装饰类的排列组合 可以创造出很多不同的行为组合 以此得到功能更为强大的对象
 *
 *      装饰类与被装饰类可以独立变化 所以是低耦合的 用户可以根据需要增加装饰类和被装饰类 在使用时再对其进行自由组合 同时又不改变原有代码 符合“开闭原则”
 *
 * 缺点
 *      会产生很多的小对象[每个装饰类对应的对象] 增加了系统的复杂性
 *
 *      比继承更灵活的特性 也意味着装饰模式比继承更加易于出错 排错也很困难 尤其是多次装饰的对象排错更为烦琐
 *
 *
 * 装饰与适配模式的区别
 *
 *      适配器模式主要用来兼容那些不能在一起工作的类 使他们转化为可以兼容目标接口 虽然也可以实现和装饰者一样的动态增强 但侧重不在此
 *
 *      装饰者模式主要是给被装饰者动态增强
 *
 * 装饰者和继承的区别
 *  继承
 *      优点 代码结构清晰 实现简单
 *      缺点 对于每一个的需要增强的类都要创建子类来实现增强 这样会导致继承体系过于庞大
 *
 *  装饰者
 *      优点 内部可以通过多态技术对多个需要增强的类进行增强
 *      缺点 由于使用多态实现增强 使得代码稍显复杂
 *
 * 使用场景
 *      需要扩展一个类的功能
 *
 *      需要动态的给对象添加功能 这些功能可能不明确或者暂时的 可以随时很方便的动态撤销掉
 *
 *      需要增加由一些基本功能排列组合而产生的非常大量的功能 从而使继承关系变的不现实
 *
 *      当不能采用生成子类的方法进行扩充时 一种情况是 可能有大量独立的扩展 为支持每一种组合将产生大量的子类 使子类数目呈指数级增长
 *      另一种情况可能是因为类定义被隐藏 或类定义不能用于生成子类
 *
 */
public class DecoratorPattern {
    //被装饰类实现的接口
    interface IPerson{
        void say();
    }

    //被装饰类
    class Person implements IPerson{
        @Override
        public void say() {
            System.out.println("say Chiness");
        }
    }

    //装饰类 实现被装饰类实现的接口
    class PersonPlus implements IPerson{
        //持有一个被装饰类的实例
        private Person person;

        //构造函数把被装饰类的实例构建进来
        public PersonPlus(Person person) {
            this.person = person;
        }

        //调用被装饰类已有的功能 扩展需要增强的功能
        @Override
        public void say() {
            person.say();
            System.out.println("say English");
        }
    }
}
